package com.ray.leetcode.resolved;

import com.ray.io.Out;

import java.util.Arrays;

/**
 * Minimize Malware Spread
 * -----------------------------------------------------------------------------
 * 在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。
 * 一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，
 * 那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
 *
 * 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
 * 我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 M(initial)， 则返回该节点。
 * 如果有多个节点满足条件，就返回索引最小的节点。
 * 请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后可能仍然因恶意软件传播而受到感染。
 *
 * Example 1
 *      Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
 *      Output: 0
 * Example 2
 *      Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
 *      Output: 0
 * Example 3
 *      Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
 *      Output: 1
 * Note:
 *      1 < graph.length = graph[0].length <= 300
 *      0 <= graph[i][j] == graph[j][i] <= 1
 *      graph[i][i] == 1
 *      1 <= initial.length <= graph.length
 *      0 <= initial[i] < graph.length
 *
 * Level : Hard
 *
 * @author  ray
 * @link    https://leetcode-cn.com/problems/minimize-malware-spread/
 * @since   2020-04-01 23:08:50
 */
public class L0960_Minimize_Malware_Spread {
    static class Solution {
        public int minMalwareSpread(int[][] graph, int[] initial) {
            Arrays.sort(initial);
            int[] group = new int[graph.length];

            int currentGroup = 1;
            for (int v : initial) {
                if (group[v] == 0) {
                    dfs(graph, group, v, currentGroup++);
                }
            }

            int[] size = new int[currentGroup];
            int[] sizeInInitial = new int[currentGroup];

            for (int i : initial)
                sizeInInitial[group[i]] ++;
            for (int g : group) {
                size[g] ++;
            }
            int ans = Integer.MAX_VALUE;
            for (int node: initial) {
                int c = group[node];
                if (c == 0) continue;
                if (sizeInInitial[c] == 1) {
                    if (ans == Integer.MAX_VALUE)
                        ans = node;
                    else if (size[c] > size[group[ans]])
                        ans = node;
                    else if (size[c] == size[group[ans]] && node < ans)
                        ans = node;
                }
            }

            if (ans == Integer.MAX_VALUE)
                for (int node: initial)
                    ans = Math.min(ans, node);
            return ans;
        }

        private void dfs(int[][] graph, int[] group, int v, int currentGroup) {
            group[v] = currentGroup;
            for (int w = 0; w < graph[v].length; w++) {
                if (v != w && graph[v][w] == 1 && group[w] == 0) {
                    group[w] = currentGroup;
                    dfs(graph, group, w, currentGroup);
                }
            }
        }
    }
    
    public static void main(String[] args) {
        int[][] g = {
                {1,1,0},
                {1,1,0},
                {0,0,1},
        };
        int[] ini = {0, 1, 2};

        Out.p(new Solution().minMalwareSpread(g, ini));
    }
}
